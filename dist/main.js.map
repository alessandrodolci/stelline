{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/canvas-object.js","webpack:///./src/index.js","webpack:///./src/loop.js","webpack:///./src/ship.js","webpack:///./src/star.js","webpack:///./src/utils.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0E;AAC5C;AACG;AACc;;AAE/C;;AAEO;AACP;AACA,mBAAmB,eAAe;AAClC,yBAAyB,0CAAI;;AAE7B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2DAAqB;AAC5D;AACA;AACA;AACA,sCAAsC,2DAAqB;AAC3D;AACA;AACA;AACA,qCAAqC,yDAAmB;AACxD;AACA;AACA;AACA,oCAAoC,yDAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mEAAoB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA,mEAAmE,aAAa;AAChF;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,0CAAI;;AAErB;;AAEA;;AAEA,mCAAmC,qDAAO;;;;;;;;;;;;;ACtG1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACN;AACE;;AAEhC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,mBAAmB,kBAAkB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,0CAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,gDAAU;;AAEhC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,qDAAW;AAC/B;AACA;;AAEA;AACA,SAAS;AACT,SAAS;AACT;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,0CAAI;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACP;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACtKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;;AAE/C;AACA;AACA;AACO;AACA;;AAEP;AACO;;AAEP;AACA;;AAEO;AACP,IAAI,2DAAY;;AAEhB;AACA;;AAEA,+BAA+B,2DAAY;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,2DAAY;;AAEhB;AACA;AACA;AACA;;AAEA,+BAA+B,2DAAY;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AAAA;AAA+C;;AAExC;AACA;AACP;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA,IAAI,2DAAY;;AAEhB;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,2DAAY;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","export function CanvasObject(initialX, initialY, size, visible) {\n    this.x = initialX;\n    this.y = initialY;\n    this.size = size;\n    this.visible = visible;\n}\n","import { Ship, SHIP_HORIZONTAL_SPEED, SHIP_VERTICAL_SPEED } from \"./ship\";\nimport { Star } from \"./star\";\nimport { animate } from \"./loop\";\nimport { deviceHasTouchScreen } from \"./utils\";\n\nconst MAX_STARS = 200;\n\nexport function getNewStars() {\n    const stars = [];\n    for (let i = 0; i < MAX_STARS; i++) {\n        const star = new Star(canvas.width / 2, canvas.height / 3);\n\n        star.move(Math.random() * (canvas.width/3));\n\n        stars.push(star);\n    }\n\n    return stars;\n}\n\nconst bindKeys = (ship) => {\n    window.onkeydown = (e) => {\n        switch (e.key) {\n            case \"ArrowLeft\":\n            case \"KeyA\":\n                ship.moveHorizontally(-SHIP_HORIZONTAL_SPEED);\n                break;\n            case \"ArrowRight\":\n            case \"KeyD\":\n                ship.moveHorizontally(SHIP_HORIZONTAL_SPEED);\n                break;\n            case \"ArrowUp\":\n            case \"KeyW\":\n                ship.moveVertically(-SHIP_VERTICAL_SPEED);\n                break;\n            case \"ArrowDown\":\n            case \"KeyS\":\n                ship.moveVertically(SHIP_VERTICAL_SPEED);\n                break;\n            case \"KeyZ\":\n                ship.fireShot();\n                break;\n            default:\n                break;\n        }\n    };\n\n    if (!deviceHasTouchScreen()) {\n        window.onwheel = (e) => {\n            ship.moveHorizontally(e.deltaX);\n            ship.moveVertically(e.deltaY);\n        };\n    }\n\n    window.onclick = (e) => {\n        ship.fireShot(e.clientX, e.clientY);\n    };\n};\n\nconst listenToOrientationChange = (ship, stars) => {\n    const clamp = (value, min, max) => {\n        return Math.min(Math.max(value, min), max);\n    };\n\n    let initialBeta = 0;\n    let initialGamma = 0;\n\n    const initialListener = (event) => {\n        initialBeta = clamp(event.beta, -90, 90);\n        initialGamma = event.gamma;\n    };\n\n    const orientationListener = (event) => {\n        const beta = clamp(event.beta - initialBeta, -90, 90);\n        const gamma = event.gamma - initialGamma;\n\n        ship.moveHorizontally(gamma / 40);\n        ship.moveVertically(beta / 20);\n\n        for (let i = 0; i < stars.length; i++) {\n            stars[i].x -= gamma / 5;\n            stars[i].y += beta / 5;\n        }\n    };\n\n    window.addEventListener(\"deviceorientation\", initialListener, { once: true });\n    window.addEventListener(\"deviceorientation\", orientationListener);\n};\n\nconst canvas = document.getElementById('stars');\n\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\n\nconst stars = getNewStars();\n\nconst ship = new Ship(canvas.width / 2, (canvas.height / 6) * 5);\n\nbindKeys(ship);\n\nlistenToOrientationChange(ship, stars);\n\nwindow.requestAnimationFrame(() => animate(ship, stars));\n","import { SHOT_SPEED } from \"./ship\";\nimport { Star } from \"./star\";\nimport { getNewStars } from \".\";\n\nconst canvas = document.getElementById('stars');\nconst context = canvas.getContext('2d');\n\nlet score = 0;\nlet gameOver = false;\n\nconst showScore = () => {\n    context.fillStyle = \"white\";\n    context.textAlign = \"left\";\n    context.font = \"24px mono\";\n    context.fillText(\"SCORE: \" + score, 10, 30);\n};\n\nexport const animateStars = (stars) => {\n    for (let i = 0; i < stars.length; i++) {\n        let star = stars[i];\n\n        if (star.visible) {\n            star.draw();\n        }\n        else if (Math.random() > 0.1) {\n            star.visible = true;\n        }\n\n        star.move();\n\n        if (star.x > canvas.width - star.size || star.x < star.size\n            || star.y > canvas.height - star.size || star.y < star.size) {\n            if (star.y > canvas.height - star.size) {\n                score++;\n            }\n            \n            star = stars.splice(i, 1, new Star(canvas.width / 2, canvas.height / 3))[0];\n            star.move(Math.random() * (canvas.width/3));\n        }\n        else {\n            star.scale();\n        }\n    }\n};\n\nconst animateShot = (shot) => {\n    shot.y = shot.y - SHOT_SPEED;\n    \n    if (shot.y === 0) {\n        shot.hit = true;\n    }\n    \n    shot.draw();\n};\n\nconst isShipColliding = (star, ship) => {\n    if (ship.x - star.x < ship.size && ship.x - star.x > -ship.size\n        && ship.y - star.y < ship.size / 2 && ship.y - star.y > -ship.size / 2\n        && star.visible === true) {\n        return true;\n    }\n\n    return false;\n};\n\nconst drawGameOver = () => {\n    context.fillStyle = \"white\";\n    context.textAlign = \"center\";\n    context.font = \"60px monospace\";\n    context.fillText(\"GAME OVER\", canvas.width / 2, canvas.height / 2);\n\n    context.font = \"38px monospace\";\n    context.fillText(\"Tap to restart\", canvas.width / 2, canvas.height / 2 + 80);\n};\n\nconst toggleObjectsVisibility = (stars, ship) => {\n    ship.visible = !gameOver;\n    \n    for (let i = 0; i < ship.shots.length; i++) {\n        ship.shots[i].hit = gameOver;\n    }\n\n    for (let i = 0; i < stars.length; i++) {\n        stars[i].visible = !gameOver;\n    }\n};\n\nconst endGame = (stars, ship) => {\n    gameOver = true;\n\n    toggleObjectsVisibility(stars, ship);\n\n    drawGameOver();\n\n    canvas.addEventListener(\n        \"pointerup\",\n        () => {\n            gameOver = false;\n\n            toggleObjectsVisibility(stars, ship);\n\n            stars = getNewStars();\n            ship.resetSize();\n            ship.setPosition(canvas.width / 2, (canvas.height / 6) * 5);\n\n            animate(ship, stars);\n        },\n        { once: true }\n    );\n};\n\nconst checkShipCollisions = (stars, ship) => {\n    for (let i = 0; i < stars.length; i++) {\n        const star = stars[i];\n        if (isShipColliding(star, ship)) {\n            ship.visible = false;\n            endGame(stars, ship);\n        }\n    }\n};\n\nconst checkShotsCollisions = (stars, shots) => {\n    for (let i = 0; i < stars.length; i++) {\n        let star = stars[i];\n        for (let j = 0; j < shots.length; j++) {\n            const shot = shots[j];\n            if (shot.x - star.x < star.size && shot.x - star.x > -star.size\n                && shot.y - star.y < star.size && shot.y - star.y > -star.size\n                && star.visible === true) {\n                shot.hit = true;\n                \n                star = stars.splice(i, 1, new Star(canvas.width / 2, canvas.height / 3))[0];\n                star.move(Math.random() * (canvas.width/3));\n            }\n        }\n    }\n};\n\nconst checkCollisions = (stars, ship) => {\n    checkShipCollisions(stars, ship);\n\n    checkShotsCollisions(stars, ship.shots);\n};\n\nexport const animate = (ship, stars) => {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    showScore();\n\n    animateStars(stars);\n\n    if (ship.visible) {\n        ship.draw();\n    }\n\n    ship.shots = ship.shots.filter((shot) => {\n        animateShot(shot);\n\n        return !shot.hit;\n    });\n\n    checkCollisions(stars, ship);\n    \n    if (!gameOver) {\n        window.requestAnimationFrame(() => animate(ship, stars));\n    }\n};\n","import { CanvasObject } from \"./canvas-object\";\n\nconst SHIP_SIZE = 30;\nconst SHIP_SCALE = 20;\nconst SHIP_LINE_WIDTH = 1.5;\nexport const SHIP_HORIZONTAL_SPEED = 1;\nexport const SHIP_VERTICAL_SPEED = 0.4;\n\nconst SHOT_SIZE = 4;\nexport const SHOT_SPEED = 4;\n\nconst canvas = document.getElementById('stars');\nconst context = canvas.getContext('2d');\n\nexport function Ship(initialX, initialY) {\n    CanvasObject.call(this, initialX, initialY, SHIP_SIZE, true);\n\n    this.shots = [];\n}\n\nShip.prototype = Object.create(CanvasObject.prototype);\nShip.prototype.constructor = Ship;\n\nShip.prototype.setPosition = function (x, y) {\n    this.x = x;\n    this.y = y;\n};\n\nShip.prototype.resetSize = function () {\n    this.size = SHIP_SIZE;\n};\n\nShip.prototype.getNoseXCoordinate = function () {\n    return this.x;\n};\n\nShip.prototype.getNoseYCoordinate = function () {\n    return this.y - this.size / 2;\n};\n\nShip.prototype.getLeftWingXCoordinate = function () {\n    return this.x - this.size;\n};\n\nShip.prototype.getRightWingXCoordinate = function () {\n    return this.x + this.size;\n};\n\nShip.prototype.getWingsYCoordinate = function () {\n    return this.y + this.size / 4;\n};\n\nShip.prototype.getTopXCoordinate = function () {\n    return this.x;\n};\n\nShip.prototype.getTopYCoordinate = function () {\n    return this.y - this.size / 8;\n};\n\nShip.prototype.getRearXCoordinate = function () {\n    return this.x;\n};\n\nShip.prototype.getRearYCoordinate = function () {\n    return this.y + this.size / 3;\n};\n\nShip.prototype.moveVertically = function (speed) {\n    const deltaX = canvas.width/2 - this.x;\n    const deltaY = canvas.height/2 - this.y;\n    const direction = Math.atan2(deltaY, deltaX);\n    this.x -= speed * Math.cos(direction);\n\n    if (this.y > canvas.height/2) {\n        this.y -= speed * Math.sin(direction);\n        this.size += speed / SHIP_SCALE;\n    }\n};\n\nShip.prototype.moveHorizontally = function (speed) {\n    this.x += speed;\n};\n\nShip.prototype.draw = function () {\n    const horizontalSkew = 2 * this.getTopXCoordinate() / canvas.width - 1;\n    context.setTransform(new DOMMatrix([1, 0, horizontalSkew, 1, 0, 0]));\n\n    context.beginPath();\n\n    context.moveTo(this.getLeftWingXCoordinate(), this.getWingsYCoordinate());\n    context.lineTo(this.getNoseXCoordinate(), this.getNoseYCoordinate());\n    context.lineTo(this.getRightWingXCoordinate(), this.getWingsYCoordinate());\n    context.lineTo(this.getRearXCoordinate(), this.getRearYCoordinate());\n    context.lineTo(this.getLeftWingXCoordinate(), this.getWingsYCoordinate());\n\n    context.moveTo(this.getTopXCoordinate(), this.getTopYCoordinate());\n    context.lineTo(this.getLeftWingXCoordinate(), this.getWingsYCoordinate());\n\n    context.moveTo(this.getTopXCoordinate(), this.getTopYCoordinate());\n    context.lineTo(this.getRightWingXCoordinate(), this.getWingsYCoordinate());\n\n    context.moveTo(this.getTopXCoordinate(), this.getTopYCoordinate());\n    context.lineTo(this.getNoseXCoordinate(), this.getNoseYCoordinate());\n\n    context .closePath();\n    context.strokeStyle = \"white\";\n    context.lineWidth = SHIP_LINE_WIDTH;\n    context.stroke();\n\n    context.setTransform();\n};\n\nShip.prototype.fireShot = function (targetX, targetY) {\n    this.shots.push(new Shot(this.getNoseXCoordinate(), this.getNoseYCoordinate(), targetX, targetY));\n};\n\nfunction Shot(originX, originY, targetX, targetY) {\n    CanvasObject.call(this, originX, originY, SHOT_SIZE, null);\n\n    this.targetX = targetX;\n    this.targetY = targetY;\n    this.hit = false;\n}\n\nShot.prototype = Object.create(CanvasObject.prototype);\nShot.prototype.constructor = Shot;\n\nShot.prototype.draw = function () {\n    context.beginPath();\n    context.ellipse(this.x, this.y, this.size / 2, this.size / 2, 0, 0, 2 * Math.PI);\n    context.closePath();\n    context.fillStyle = \"grey\";\n    context.fill();\n};\n","import { CanvasObject } from \"./canvas-object\";\n\nexport const MIN_STAR_SIZE = 0.2;\nexport const MAX_STAR_SIZE = 7;\nconst MAX_INITIAL_STAR_SIZE = MAX_STAR_SIZE / 2;\nconst BASE_SIZE_SCALE_FACTOR = 0.002;\nconst BASE_SPEED_SCALE_FACTOR = 0.008;\n\nconst canvas = document.getElementById('stars');\nconst context = canvas.getContext('2d');\n\nexport function Star(initialX, initialY) {\n    const size = Math.random() * (MAX_INITIAL_STAR_SIZE - MIN_STAR_SIZE) + MIN_STAR_SIZE;\n    CanvasObject.call(this, initialX, initialY, size, false);\n\n    this.initialX = initialX;\n    this.initialY = initialY;\n    this.vx = Math.min(1, this.size / 2) * (Math.random() - 0.5);\n    this.vy = Math.min(1, this.size / 2) * (Math.random() - 0.5);\n}\n\nStar.prototype = Object.create(CanvasObject.prototype);\nStar.prototype.constructor = Star;\n\nStar.prototype.move = function (movementFactor = 1) {\n    this.x += this.vx * movementFactor;\n    this.y += this.vy * movementFactor;\n};\n\nStar.prototype.scale = function (scaleFactor = 1) {\n    if (this.size < MAX_STAR_SIZE) {\n        this.size += this.size * BASE_SIZE_SCALE_FACTOR * scaleFactor;\n    }\n\n    this.vx += this.vx *  BASE_SPEED_SCALE_FACTOR * scaleFactor;\n    this.vy += this.vy * BASE_SPEED_SCALE_FACTOR * scaleFactor;\n};\n\nStar.prototype.draw = function () {\n    context.beginPath();\n    context.ellipse(this.x, this.y, this.size / 2, this.size / 2, 0, 0, 2 * Math.PI);\n    context.closePath();\n    context.fillStyle = \"white\";\n    context.fill();\n};\n","export function deviceHasTouchScreen() {\n    let hasTouchScreen = false;\n\n    if (\"maxTouchPoints\" in navigator) {\n        hasTouchScreen = navigator.maxTouchPoints > 0;\n    }\n    else if (\"msMaxTouchPoints\" in navigator) {\n        hasTouchScreen = navigator.msMaxTouchPoints > 0;\n    }\n\n    return hasTouchScreen;\n}\n"],"sourceRoot":""}