{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACL0E;AAC5C;AACG;AACc;;AAE/C;;AAEO;AACP;AACA,oBAAoB,eAAe;AACnC,yBAAyB,uCAAI;;AAE7B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wDAAqB;AAC5D;AACA;AACA;AACA,sCAAsC,wDAAqB;AAC3D;AACA;AACA;AACA,qCAAqC,sDAAmB;AACxD;AACA;AACA;AACA,oCAAoC,sDAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,4DAAoB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oEAAoE,YAAY;AAChF;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,uCAAI;;AAErB;;AAEA;;AAEA,mCAAmC,8CAAO;;;;;;;;;;;;;;;;;;;ACjGN;AACN;AACE;;AAEhC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,6CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,8CAAW;AAC/B;AACA;;AAEA;AACA,SAAS;AACT,UAAU;AACV;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA,+BAA+B,uCAAI;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACP;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtK+C;;AAE/C;AACA;AACA;AACA;AACO;AACA;;AAEP;AACO;;AAEP;AACA;;AAEO;AACP,IAAI,6DAAiB;;AAErB;AACA;;AAEA,+BAA+B,kEAAsB;AACrD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,6DAAiB;;AAErB;AACA;AACA;AACA;;AAEA,+BAA+B,kEAAsB;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpI+C;;AAExC;AACA;AACP;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA,IAAI,6DAAiB;;AAErB;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,kEAAsB;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5CO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;UCXA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack://stelline/./src/canvas-object.js","webpack://stelline/./src/index.js","webpack://stelline/./src/loop.js","webpack://stelline/./src/ship.js","webpack://stelline/./src/star.js","webpack://stelline/./src/utils.js","webpack://stelline/webpack/bootstrap","webpack://stelline/webpack/runtime/define property getters","webpack://stelline/webpack/runtime/hasOwnProperty shorthand","webpack://stelline/webpack/runtime/make namespace object","webpack://stelline/webpack/before-startup","webpack://stelline/webpack/startup","webpack://stelline/webpack/after-startup"],"sourcesContent":["export function CanvasObject(initialX, initialY, size, visible) {\n    this.x = initialX;\n    this.y = initialY;\n    this.size = size;\n    this.visible = visible;\n}\n","import { Ship, SHIP_HORIZONTAL_SPEED, SHIP_VERTICAL_SPEED } from \"./ship\";\nimport { Star } from \"./star\";\nimport { animate } from \"./loop\";\nimport { deviceHasTouchScreen } from \"./utils\";\n\nconst MAX_STARS = 200;\n\nexport function getNewStars() {\n    const stars = [];\n    for (let i = 0; i < MAX_STARS; i++) {\n        const star = new Star(canvas.width / 2, canvas.height / 3);\n\n        star.move(Math.random() * (canvas.width/3));\n\n        stars.push(star);\n    }\n\n    return stars;\n}\n\nconst bindKeys = (ship) => {\n    window.onkeydown = (e) => {\n        switch (e.key) {\n            case \"ArrowLeft\":\n            case \"KeyA\":\n                ship.moveHorizontally(-SHIP_HORIZONTAL_SPEED);\n                break;\n            case \"ArrowRight\":\n            case \"KeyD\":\n                ship.moveHorizontally(SHIP_HORIZONTAL_SPEED);\n                break;\n            case \"ArrowUp\":\n            case \"KeyW\":\n                ship.moveVertically(-SHIP_VERTICAL_SPEED);\n                break;\n            case \"ArrowDown\":\n            case \"KeyS\":\n                ship.moveVertically(SHIP_VERTICAL_SPEED);\n                break;\n            case \"KeyZ\":\n                ship.fireShot();\n                break;\n            default:\n                break;\n        }\n    };\n\n    if (!deviceHasTouchScreen()) {\n        window.onwheel = (e) => {\n            ship.moveHorizontally(e.deltaX);\n            ship.moveVertically(e.deltaY);\n        };\n    }\n\n    window.onclick = (e) => {\n        ship.fireShot(e.clientX, e.clientY);\n    };\n};\n\nconst listenToOrientationChange = (ship) => {\n    const clamp = (value, min, max) => {\n        return Math.min(Math.max(value, min), max);\n    };\n\n    let initialBeta = 0;\n    let initialGamma = 0;\n\n    const initialListener = (event) => {\n        initialBeta = clamp(event.beta, -90, 90);\n        initialGamma = event.gamma;\n    };\n\n    const orientationListener = (event) => {\n        const beta = clamp(event.beta - initialBeta, -90, 90);\n        const gamma = event.gamma - initialGamma;\n\n        ship.moveHorizontally(gamma / 20);\n        ship.moveVertically(beta / 10);\n    };\n\n    window.addEventListener(\"deviceorientation\", initialListener, { once: true });\n    window.addEventListener(\"deviceorientation\", orientationListener);\n};\n\nconst canvas = document.getElementById('stars');\n\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\n\nconst stars = getNewStars();\n\nconst ship = new Ship(canvas.width / 2, (canvas.height / 6) * 5);\n\nbindKeys(ship);\n\nlistenToOrientationChange(ship, stars);\n\nwindow.requestAnimationFrame(() => animate(ship, stars));\n","import { SHOT_SPEED } from \"./ship\";\nimport { Star } from \"./star\";\nimport { getNewStars } from \".\";\n\nconst canvas = document.getElementById('stars');\nconst context = canvas.getContext('2d');\n\nlet score = 0;\nlet gameOver = false;\n\nconst showScore = () => {\n    context.fillStyle = \"white\";\n    context.textAlign = \"left\";\n    context.font = \"24px mono\";\n    context.fillText(\"SCORE: \" + score, 10, 30);\n};\n\nexport const animateStars = (stars) => {\n    for (let i = 0; i < stars.length; i++) {\n        let star = stars[i];\n\n        if (star.visible) {\n            star.draw();\n        }\n        else if (Math.random() > 0.1) {\n            star.visible = true;\n        }\n\n        star.move();\n\n        if (star.x > canvas.width - star.size || star.x < star.size\n            || star.y > canvas.height - star.size || star.y < star.size) {\n            if (star.y > canvas.height - star.size) {\n                score++;\n            }\n            \n            stars[i] = new Star(canvas.width / 2, canvas.height / 3);\n            stars[i].move(Math.random() * (canvas.width/6));\n        }\n        else {\n            star.scale();\n        }\n    }\n};\n\nconst animateShot = (shot) => {\n    shot.y = shot.y - SHOT_SPEED;\n    \n    if (shot.y === 0) {\n        shot.hit = true;\n    }\n    \n    shot.draw();\n};\n\nconst isShipColliding = (star, ship) => {\n    return ship.x - star.x < ship.size && ship.x - star.x > -ship.size\n        && ship.y - star.y < ship.size / 2 && ship.y - star.y > -ship.size / 2\n        && star.visible;\n};\n\nconst isShotColliding = (star, shot) => {\n    return shot.x - star.x < star.size && shot.x - star.x > -star.size\n        && shot.y - star.y < star.size && shot.y - star.y > -star.size\n        && star.visible;\n};\n\nconst drawGameOver = () => {\n    context.fillStyle = \"white\";\n    context.textAlign = \"center\";\n    context.font = \"60px monospace\";\n    context.fillText(\"GAME OVER\", canvas.width / 2, canvas.height / 2);\n\n    context.font = \"38px monospace\";\n    context.fillText(\"Tap to restart\", canvas.width / 2, canvas.height / 2 + 80);\n};\n\nconst toggleObjectsVisibility = (stars, ship) => {\n    ship.visible = !gameOver;\n    \n    for (let i = 0; i < ship.shots.length; i++) {\n        ship.shots[i].hit = gameOver;\n    }\n\n    for (let i = 0; i < stars.length; i++) {\n        stars[i].visible = !gameOver;\n    }\n};\n\nconst endGame = (stars, ship) => {\n    gameOver = true;\n\n    toggleObjectsVisibility(stars, ship);\n\n    drawGameOver();\n\n    canvas.addEventListener(\n        \"pointerup\",\n        () => {\n            gameOver = false;\n\n            toggleObjectsVisibility(stars, ship);\n\n            stars = getNewStars();\n            ship.resetSize();\n            ship.setPosition(canvas.width / 2, (canvas.height / 6) * 5);\n\n            animate(ship, stars);\n        },\n        { once: true }\n    );\n};\n\nconst checkShipCollisions = (stars, ship) => {\n    for (let i = 0; i < stars.length; i++) {\n        const star = stars[i];\n        if (isShipColliding(star, ship)) {\n            ship.visible = false;\n            endGame(stars, ship);\n        }\n    }\n};\n\nconst checkShotsCollisions = (stars, shots) => {\n    for (let i = 0; i < stars.length; i++) {\n        let star = stars[i];\n        for (let j = 0; j < shots.length; j++) {\n            const shot = shots[j];\n            if (isShotColliding(star, shot)) {\n                shot.hit = true;\n                \n                stars[i] = new Star(canvas.width / 2, canvas.height / 3);\n                stars[i].move(Math.random() * (canvas.width/6));\n            }\n        }\n    }\n};\n\nconst checkCollisions = (stars, ship) => {\n    checkShipCollisions(stars, ship);\n\n    checkShotsCollisions(stars, ship.shots);\n};\n\nexport const animate = (ship, stars) => {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    showScore();\n\n    animateStars(stars);\n\n    if (ship.visible) {\n        ship.draw();\n    }\n\n    ship.shots = ship.shots.filter((shot) => {\n        animateShot(shot);\n\n        return !shot.hit;\n    });\n\n    checkCollisions(stars, ship);\n    \n    if (!gameOver) {\n        window.requestAnimationFrame(() => animate(ship, stars));\n    }\n};\n","import { CanvasObject } from \"./canvas-object\";\n\nconst SHIP_SIZE = 30;\nconst SHIP_SCALE = 20;\nconst SHIP_LINE_WIDTH = 1.5;\nconst SHIP_SKEW_FACTOR = 0.02;\nexport const SHIP_HORIZONTAL_SPEED = 1;\nexport const SHIP_VERTICAL_SPEED = 0.4;\n\nconst SHOT_SIZE = 4;\nexport const SHOT_SPEED = 4;\n\nconst canvas = document.getElementById('stars');\nconst context = canvas.getContext('2d');\n\nexport function Ship(initialX, initialY) {\n    CanvasObject.call(this, initialX, initialY, SHIP_SIZE, true);\n\n    this.shots = [];\n}\n\nShip.prototype = Object.create(CanvasObject.prototype);\nShip.prototype.constructor = Ship;\n\nconst getShipHorizontalSkew = (shipX) => ((canvas.width / 2) - shipX) * SHIP_SKEW_FACTOR;\n\nShip.prototype.setPosition = function (x, y) {\n    this.x = x;\n    this.y = y;\n};\n\nShip.prototype.resetSize = function () {\n    this.size = SHIP_SIZE;\n};\n\nShip.prototype.getNoseXCoordinate = function () {\n    return this.x;\n};\n\nShip.prototype.getNoseYCoordinate = function () {\n    return this.y - this.size / 2;\n};\n\nShip.prototype.getLeftWingXCoordinate = function () {\n    return this.x - this.size - getShipHorizontalSkew(this.x);\n};\n\nShip.prototype.getRightWingXCoordinate = function () {\n    return this.x + this.size - getShipHorizontalSkew(this.x);\n};\n\nShip.prototype.getWingsYCoordinate = function () {\n    return this.y + this.size / 4;\n};\n\nShip.prototype.getTopXCoordinate = function () {\n    return this.x - getShipHorizontalSkew(this.x);\n};\n\nShip.prototype.getTopYCoordinate = function () {\n    return this.y - this.size / 8;\n};\n\nShip.prototype.getRearXCoordinate = function () {\n    return this.x - getShipHorizontalSkew(this.x);\n};\n\nShip.prototype.getRearYCoordinate = function () {\n    return this.y + this.size / 3;\n};\n\nShip.prototype.moveVertically = function (speed) {\n    const deltaX = canvas.width/2 - this.x;\n    const deltaY = canvas.height/2 - this.y;\n    const direction = Math.atan2(deltaY, deltaX);\n    this.x -= speed * Math.cos(direction);\n\n    if (this.y > canvas.height/2) {\n        this.y -= speed * Math.sin(direction);\n        this.size += speed / SHIP_SCALE;\n    }\n};\n\nShip.prototype.moveHorizontally = function (speed) {\n    this.x += speed;\n};\n\nShip.prototype.draw = function () {\n    context.beginPath();\n\n    context.moveTo(this.getLeftWingXCoordinate(), this.getWingsYCoordinate());\n    context.lineTo(this.getNoseXCoordinate(), this.getNoseYCoordinate());\n    context.lineTo(this.getRightWingXCoordinate(), this.getWingsYCoordinate());\n    context.lineTo(this.getRearXCoordinate(), this.getRearYCoordinate());\n    context.lineTo(this.getLeftWingXCoordinate(), this.getWingsYCoordinate());\n\n    context.moveTo(this.getTopXCoordinate(), this.getTopYCoordinate());\n    context.lineTo(this.getLeftWingXCoordinate(), this.getWingsYCoordinate());\n\n    context.moveTo(this.getTopXCoordinate(), this.getTopYCoordinate());\n    context.lineTo(this.getRightWingXCoordinate(), this.getWingsYCoordinate());\n\n    context.moveTo(this.getTopXCoordinate(), this.getTopYCoordinate());\n    context.lineTo(this.getNoseXCoordinate(), this.getNoseYCoordinate());\n\n    context .closePath();\n    context.strokeStyle = \"white\";\n    context.lineWidth = SHIP_LINE_WIDTH;\n    context.stroke();\n};\n\nShip.prototype.fireShot = function (targetX, targetY) {\n    this.shots.push(new Shot(this.getNoseXCoordinate(), this.getNoseYCoordinate(), targetX, targetY));\n};\n\nfunction Shot(originX, originY, targetX, targetY) {\n    CanvasObject.call(this, originX, originY, SHOT_SIZE, null);\n\n    this.targetX = targetX;\n    this.targetY = targetY;\n    this.hit = false;\n}\n\nShot.prototype = Object.create(CanvasObject.prototype);\nShot.prototype.constructor = Shot;\n\nShot.prototype.draw = function () {\n    context.beginPath();\n    context.ellipse(this.x, this.y, this.size / 2, this.size / 2, 0, 0, 2 * Math.PI);\n    context.closePath();\n    context.fillStyle = \"grey\";\n    context.fill();\n};\n","import { CanvasObject } from \"./canvas-object\";\n\nexport const MIN_STAR_SIZE = 0.2;\nexport const MAX_STAR_SIZE = 7;\nconst MAX_INITIAL_STAR_SIZE = MAX_STAR_SIZE / 2;\nconst BASE_SIZE_SCALE_FACTOR = 0.002;\nconst BASE_SPEED_SCALE_FACTOR = 0.008;\n\nconst canvas = document.getElementById('stars');\nconst context = canvas.getContext('2d');\n\nexport function Star(initialX, initialY) {\n    const size = Math.random() * (MAX_INITIAL_STAR_SIZE - MIN_STAR_SIZE) + MIN_STAR_SIZE;\n    CanvasObject.call(this, initialX, initialY, size, false);\n\n    this.initialX = initialX;\n    this.initialY = initialY;\n    this.vx = Math.min(1, this.size / 2) * (Math.random() - 0.5);\n    this.vy = Math.min(1, this.size / 2) * (Math.random() - 0.5);\n}\n\nStar.prototype = Object.create(CanvasObject.prototype);\nStar.prototype.constructor = Star;\n\nStar.prototype.move = function (movementFactor = 1) {\n    this.x += this.vx * movementFactor;\n    this.y += this.vy * movementFactor;\n};\n\nStar.prototype.scale = function (scaleFactor = 1) {\n    if (this.size < MAX_STAR_SIZE) {\n        this.size += this.size * BASE_SIZE_SCALE_FACTOR * scaleFactor;\n    }\n\n    this.vx += this.vx *  BASE_SPEED_SCALE_FACTOR * scaleFactor;\n    this.vy += this.vy * BASE_SPEED_SCALE_FACTOR * scaleFactor;\n};\n\nStar.prototype.draw = function () {\n    context.beginPath();\n    context.ellipse(this.x, this.y, this.size / 2, this.size / 2, 0, 0, 2 * Math.PI);\n    context.closePath();\n    context.fillStyle = \"white\";\n    context.fill();\n};\n","export function deviceHasTouchScreen() {\n    let hasTouchScreen = false;\n\n    if (\"maxTouchPoints\" in navigator) {\n        hasTouchScreen = navigator.maxTouchPoints > 0;\n    }\n    else if (\"msMaxTouchPoints\" in navigator) {\n        hasTouchScreen = navigator.msMaxTouchPoints > 0;\n    }\n\n    return hasTouchScreen;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.js\");\n",""],"names":[],"sourceRoot":""}